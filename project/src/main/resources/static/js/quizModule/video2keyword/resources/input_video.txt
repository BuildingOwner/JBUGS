(post-order traverse): D EB F G C A
9
self.data = data
• 크기(size): 트리에 포함된 모든 노드의 개수
• ¢ 위 순회(post-order traverse): D → E → B → F G C - A
|(in-order traverse): D - B - E “A → F C G
[입력 예시 ]
• [Step 2] 현재 노드와 값을 비교합니다.
5
(30)
de)
(in-order traverse): D - B- EAF
post_order(tree['A'])
+
11
21
• 찾고자 하는 원소: 37°
· 이진 탐색 트리가 이미 구성되어 있다고 가정하고 데이터를 조회하는 과정을 살펴봅시다.
(pre-order traverse): A B D E C F G
전위 순 (pre-order traverse): A - B → D - E - C - F → G
print(node.data, end=' ')
6
E
# 4 (Inorder Traversal)
35
DE BFGCA:
• 중위 순회(in-order traverse): 왼쪽 자식을 방문한 뒤에 루트를 방문합니다.
Y
(Preorder Traversal )
# $9 (Postorder Traversal)
(in-order traverse): D - B- EA F- C G
• 기본적으로 트리의 크기가 N일 때, 전체 간선의 개수는 N-1개입니다.
# (Inorder Traversal)
G
• 부모 노드보다 왼쪽 자식 노드가 작습니다.
• ¢ £|(post-order traverse): D - E - B - F - G C - A
data, left_node, right_node = input().split()
in_order(tree[ 'A'])
E2] (Tree)
o
• 대표적인 트리 순회 방법은 다음과 같습니다.
# 2 9 |(Inorder Traversal)
32
Q
L
(post-order traverse): D EBF- G CA
in-order traverse): D B EA F- C- G
ndb796 (Dongbin Na) - GitHub x
Repl.it - WellmadeDeepskyblue x ndb796 (Dongbin Na) · GitHub x
• 1912 |(pre-order traverse): A - B D - E → C → F→G
Replit - WellmadeDeepskyblue. x ndb796 (Dongbin Na) - GitHub x
-
tree = {}
E트리 (Tree)
우
• 높이(height): 깊이 중 최댓값
def in_order (node):
pre_order(tree[node. left_node ])
F None None
_init__(self, data, Left_node, right_node):
17
post_order(tree[node.left_node])
m
(post-order traverse): D EB F G - CA
41
- 0
definit__(self, data, left_node, right_node):
· 트리 자료구조에 포함된 노드를 특정한 방법으로 한 번씩 방문하는 방법을 의미합니다.
으서수의 크(Drinritv nuD I이
· 이진 탐색 트리의 특징: 왼쪽 자식 노드 <부모 노드 < 오른쪽 자식 노드
@anonymous / WellmadeDeepskyblu... av
DEBF G C A
if node.left_node != None
7
E29
o (in-order traverse): D B EA F- C G
# 2191 (Preorder Traversal)
(pre-order traverse): A B D E-» C- F - G
Python 3.8.2 (default, Feb 26 2020, 02:56:10)
def in_order
(post-order traverse): D EB F- G C A
# 2 (Preorder Traversal)
4
Stop
· 단말 노드(leaf node): 자식이 없는 노드
2) 원소를 찾았으므로 탐색을 종료
• ¢ 1 20|(post-order traverse): D.- E → B F - G C - A
B E
def
replit/repls/Wellmade DeepskyblueBootstrapping
(post-order traverse): D EBF> G C A
· 부모 노드보다 오른쪽 자식 노드가 큽니다.
• 찾고자 하는 원소: 37.
B
[입력 예시]
26
DBEAFCG
27
if node.right node != None:
• ¢
16
. 부모 노드보다 오른쪽 자식 노드가 큽니다.
| 2) 찾는 원소가 더 작으므로 왼쪽 방문
BDE
• E11 회(pre-order traverse): A - B - D → E C→F→G
in_order(tree[node.left_node ])
47
쪽
class Node:
ndb796 (Dongbin Na) - GitHub
DBE AFC G
A B DE CF G
left_node = None
· 4순회(in-order traverse): D – B → E→A→F→C→G
18
50
• [Step 1] 루트 노드부터 방문하여 탐색을 진행합니다.
(pre-order traverse): A -BD E-» C- F - G
def _init__(self, data, left_node, right_node):
pre_order(tree'A'])
→ C r epl.it/repls/Wellmade DeepskyblueBootstrapping
right_node = None
· 이진 탐색이 동작할 수 있도록 고안된 효율적인 탐색이 가능한 자료구조의 일종입니다.
48
• 부모 노드보다 오른쪽 자식 노드가 큽니다.
CEG
if node.left_node = None:
>
→ C replit/repls/WellmadeDeepskyblueBootstrapping
Run
• 1 회(in-order traverse): D → B → E → A F→ C G
DBEAF CG
Replit - WellmadeDeepskyblue. X ndb796 (Dongbin Na) - GitHub x
def post_order (node):
#
10
부모 노드보다 오른쪽 자식 노드가 큽니다.
DEBFGCA:
in_order(treel'A'])
|(pre-order traverse): A - BD E- - E -C-G
38
191순회(pre-order traverse): A - B - D - E → G→F→G
post_order(tree[node.right_node])
if node.left_node != None:
트리의 순회 (Tree Traversal) 구현 예제
2
print (noae.aata, ena
• 찾고자 하는 원소: 37。 -
tree[data] = Node(data, left_node, right_node)
순회(in-order traverse): D → B → E → A → F→C→G
39
• ¢ 1 20|(post-order traverse): D - E → B F - G C - A
8
[트리 관련 용어]
• 차수(degree): 각 노드의 (자식 방향) 간선 개수
중위 순회(in-order traverse): D → B → E → A → F→C G
if node.right_node != None:
| [Step 1] 루트 노드부터 방문하여 탐색을 진행합니다.
· |(inorder traverse): D - B- EA F-ACG
F
(post-order traverse): D EB F G- C A
순회 (Tree Traversal)
Preorder Traversal)
이진 탐색 트리가 이미 구성되어 있다고 가정하고 데이터를 조회하는 과정을 살펴봅시다.
OF
o |(in-order traverse): D B B A F-ACG
if right_node == "None":
33
1) 현재 노드와 찾는 원소 37을 비교
postorder (tree['A'])
른
· 중위 순회(in-order traverse): 왼쪽 자식을 방문한 뒤에 루트를 방문합니다.
post_order(tree[node.right_node ])
(post-order traverse): D E B F- G - C- A
29
• 192|(pre-order traverse): A + B D → E → C → F→G
ABDECFG
37
self data = data
• Ol 회(in-order traverse): D → B → E → A → F→ C G
31
self.left_node = left_node
0
23
O
· 트리는 가계도와 같은 계층적인 구조를 표현할 때 사용할 수 있는 자료구조입니다.
@anonymous / Wellmade Deepskyblu... a
36
• T |(in-order traverse): D → B → E → A → → C G
30
30.
(post-order traverse): DEB F> G CA
(pre-order traverse): A- BD E-» C- F - G
n = int(input())
42
post_order(tree[node. left_node ])
E None None
¢ |(post-order traverse): D - E - B - F - G - C - A
· 루트 노드(root node): 부모가 없는 최상위 노드
e main.py
• 트리 자료구조에 포함된 노드를 특정한 방법으로 한 번씩 방문하는 방법을 의미합니다.
전위 순 (pre-order traverse): A - B - D - E - C - F → G
• 이진 탐색 트리의 특징: 왼쪽 자식 노드 < 부모 노드 < 오른쪽 자식 노드
| 2) 원소를 찾았으므로 탐색을 종료
(Inorder Traversal)
13
Talk
pre_order(tree[node. right_node ])
C F G
순회(in-order traverse): D → B → E → A → F C G
A
중위 순회(in-order traverse): D → B → E → A → F→ →G
14
2) 찾는 원소가 더 크므로 오른쪽 방문
D
· 09 20|(post-order traverse): D - E - B -FGCA
pre_order(tree[node.left_node ])
· 부모 노드보다 왼쪽 자식 노드가 작습니다.
|(post-order traverse): D - E → B - →G → C → A
위
n = int(input()
v
· 후위 순회(post-order traverse): 오른쪽 자식을 방문한 뒤에 루트를 방문합니다.
으서수의 크Drinritv nuD I이
@anonymous / WellmadeDeepskyblu... a
Repl.it - WellmadeDeepskyblue x
· 이진 탐색 트리의 특징: 왼쪽 자식 노드 < 부모 노드 < 오른쪽 자식 노드
DE BFGCAS
• 중위 2 회(in-order traverse): D → B → E → A → F→ C → G
АВС
이진 탐색 트리 (Binary Search Tree)
in_order(tree[node. left_node ])
34
BD E
24
E2 (Tree Traversal)
def __init_(self, data, left_node, right_node):
G None None
(post-order traverse): DEBF» G C A
루트 노드(root node): 부모가 없는 최상위 노드
# 9 (Postorder Traversal)
· 찾고자 하는 원소: 37
· 트리의 정보를 시각적으로 확인할 수 있습니다.
40
• 찾고자 하는 원소: 37
(in-order traverse): D - B- EAF- C G
def pre_order (node):
|(Inorder Traversal)
20
순회(in-order traverse): D → B → E → A→ F→C→G
(pre-order traverse): A- B D E-» C- F - G
•
for i in range(n):
if node.leftnode != None:
44
DE BFGCA
if node.left_node"!= None:
큐(Priority Queue)
# Postorder Traversal)
print(node.data, end=')
in_order(tree['A'])
@anonymous / Wellmade Deepskyblu.. a
1. 부모 노드보다 왼쪽 자식 노드가 작습니다.
in-order traverse): D - B- EA F- C G
(Preorder Traversal)
if left_node == "None":
print()
def in_order(node):
o pre_order(tree[node. left_node ])
# 4 (Postorder Traversal)
• E11 회(pre-order traverse): A - B - D - E →C→F→G
post_order(tree[node.left_node ])
if node.left_node ? = None:
25
· 이진 탐색 트리의 특징: 왼쪽 자식 노드 < 뿌모 노드 < 오른쪽 자식 노드
(pre-order traverse): A - BD E-» C- F - G
DBE AFCG
• Ol 회(in-order traverse): D → B → E → A → F→ C → G.
pre_order(tree['A'])
def pre_order(node):
Sign up
3
ABDECF G
후위 순회(post-order traverse): D → E - B → F - G - C - A
• ¢ £|(post-order traverse): D - E - B - F - G - C - A
[Step 1] 루트 노드부터 방문하여 탐색을 진행합니다.
in_order(tree[node.right_node])
I
중위 순회(in-order traverse): D → B → E → A → F→C → G
· 대표적인 트리 순회 방법은 다음과 같습니다.
# (Postorder Traversal)
CF G
• 전위 순회(pre-order traverse): 루트를 먼저 방문합니다.
깊이(depth): 루트 노드부터의 거리
크기(size): 트리에 포함된 모든 노드의 개수
repl.it/repls/WellmadeDeepskyblueBootstrapping
°. 부모 노드보다 오른쪽 자식 노드가 큽니다.
LL
pre_order(tree node. right_node ])
| |(post-order traverse): D - E - B - F - G CA
• Ol |(in-order traverse): D → B → E → A → F→ C → G.
tree[data] = Node (data, left_node, right_node)
12
&
| 2) 찾는 원소가 더 크므로 오른쪽 방문
후위 순회(post-order traverse): 오른쪽 자식을 방문한 뒤에 루트를 방문합니다.
• £순회(in-order traverse): D → B → E → A→ F→C→G
dee _init__(self, data, left_node, right_node):
Inorder Traversal)
1
• Ol 회(in-order traverse): D → B → E → A F→ C → G.
D None None
· (in-order traverse): D - B- EA F-ACG
print(node.data, end='')
48.
45
• 191순회(pre-order traverse): A → B →D →E →C F→G
|(in-order traverse): D - B → E “A F - C- G
2) 찾는 원소가 더 작으므로 왼쪽 방문
CFG
· 이진 탐색 트리의 특징: 왼쪽 자식 노드 부모 노드 < 오른쪽 자식 노드
in_order(tree 'A'])
def post_order(node):
46
28
Replit - WellmadeDeepskyblue x ndb796 (Dongbin Na) · GitHub x
ABC
C
43
• |(in-order traverse): D - B - E → A → - C G
• [Step 3] 현재 노드와 값을 비교합니다.
22
· 이진 탐색 트리의 특징: 왼쪽 자식 노드< 부모 노드 < 오른쪽 자식 노드
트리의 순회 Tree Traversal)
def __init__(self, data, left_node, right_node):
• 기본적으로 트리의 크기가 N일 때, 전체 간선의 개수는 N - 1개입니다.
Files
__init__(self, data, Left_node, right_node):
• Oo |(in-order traverse): D → B → E → A → F = C G
• 1912|(pre-order traverse): A - B - D - E -C-FG
main.py
| 우선순위 큐(Priority Queue)
replit/repls/WellmadeDeepskyblueBootstrapping
19
15
(post-order traverse): D EBF- G C A
트리의 순회 (Tree Traversal) |
· 차수(degree): 각 노드의 (자식 방향) 간선 개수
트리의 순회 (Tree Traversal)
post_order(tree[node. right_node ])
self.right_node = right_node
(pre-order traverse): A BD E-» C- F - G0
D None None
• ¢ 위 순회(post-order traverse): D → E → B → F G C - A
if node.right_node != None:
dee _init__(self, data, left_node, right_node):
in_order(tree 'A'])
# 2 (Preorder Traversal)
BD E
| 2) 찾는 원소가 더 작으므로 왼쪽 방문
_init__(self, data, Left_node, right_node):
# Postorder Traversal)
• 찾고자 하는 원소: 37°
tree[data] = Node(data, left_node, right_node)
· 이진 탐색 트리의 특징: 왼쪽 자식 노드 부모 노드 < 오른쪽 자식 노드
in-order traverse): D - B- EA F- C G
for i in range(n):
LL
• T |(in-order traverse): D → B → E → A → → C G
pre_order(tree[node.left_node ])
· 루트 노드(root node): 부모가 없는 최상위 노드
| 우선순위 큐(Priority Queue)
(post-order traverse): DEBF» G C A
1. 부모 노드보다 왼쪽 자식 노드가 작습니다.
· 중위 순회(in-order traverse): 왼쪽 자식을 방문한 뒤에 루트를 방문합니다.
|(in-order traverse): D - B → E “A F - C- G
• |(in-order traverse): D - B - E → A → - C G
OF
44
• 중위 2 회(in-order traverse): D → B → E → A → F→ C → G
if right_node == "None":
39
• E11 회(pre-order traverse): A - B - D - E →C→F→G
(in-order traverse): D - B- EA F- C G
• Ol 회(in-order traverse): D → B → E → A → F→ C G
print()
19
+
(post-order traverse): D EB F- G C A
Y
16
BDE
· 대표적인 트리 순회 방법은 다음과 같습니다.
30.
G None None
· 단말 노드(leaf node): 자식이 없는 노드
• ¢
DEBF G C A
· 부모 노드보다 오른쪽 자식 노드가 큽니다.
13
• 191순회(pre-order traverse): A → B →D →E →C F→G
20
• 기본적으로 트리의 크기가 N일 때, 전체 간선의 개수는 N - 1개입니다.
ndb796 (Dongbin Na) - GitHub x
¢ |(post-order traverse): D - E - B - F - G - C - A
O
def __init__(self, data, left_node, right_node):
(pre-order traverse): A BD E-» C- F - G
(post-order traverse): D EB F G C A
중위 순회(in-order traverse): D → B → E → A → F→C G
pre_order(tree node. right_node ])
n = int(input()
•
de)
@anonymous / WellmadeDeepskyblu... a
B
• Ol 회(in-order traverse): D → B → E → A → F→ C → G.
21
크기(size): 트리에 포함된 모든 노드의 개수
31
@anonymous / Wellmade Deepskyblu.. a
Replit - WellmadeDeepskyblue. x ndb796 (Dongbin Na) - GitHub x
>
def in_order(node):
18
루트 노드(root node): 부모가 없는 최상위 노드
· 부모 노드보다 왼쪽 자식 노드가 작습니다.
CFG
| 2) 원소를 찾았으므로 탐색을 종료
print(node.data, end=')
(post-order traverse): D EB F G- C A
(in-order traverse): D - B- EAF- C G
E
in_order(treel'A'])
• 트리 자료구조에 포함된 노드를 특정한 방법으로 한 번씩 방문하는 방법을 의미합니다.
(Preorder Traversal)
if node.left_node ? = None:
| [Step 1] 루트 노드부터 방문하여 탐색을 진행합니다.
self.right_node = right_node
전위 순 (pre-order traverse): A - B - D - E - C - F → G
• ¢ £|(post-order traverse): D - E - B - F - G C - A
if left_node == "None":
@anonymous / WellmadeDeepskyblu... av
# (Postorder Traversal)
#
@anonymous / Wellmade Deepskyblu... a
6
• 찾고자 하는 원소: 37。 -
ndb796 (Dongbin Na) - GitHub
DE BFGCA
• [Step 1] 루트 노드부터 방문하여 탐색을 진행합니다.
트리의 순회 (Tree Traversal)
post_order(tree[node.left_node ])
Run
# (Inorder Traversal)
DBEAF CG
7
• 1912|(pre-order traverse): A - B - D - E -C-FG
41
48
in_order(tree[node. left_node ])
Preorder Traversal)
부모 노드보다 오른쪽 자식 노드가 큽니다.
(pre-order traverse): A -BD E-» C- F - G
tree = {}
o
in_order(tree['A'])
post_order(tree[node.right_node ])
definit__(self, data, left_node, right_node):
postorder (tree['A'])
32
· 09 20|(post-order traverse): D - E - B -FGCA
__init__(self, data, Left_node, right_node):
C F G
2) 찾는 원소가 더 작으므로 왼쪽 방문
29
(post-order traverse): D EBF- G C A
post_order(tree[node.left_node])
순회 (Tree Traversal)
post_order(tree[node.right_node])
으서수의 크(Drinritv nuD I이
repl.it/repls/WellmadeDeepskyblueBootstrapping
A B DE CF G
48.
전위 순 (pre-order traverse): A - B → D - E - C - F → G
E2 (Tree Traversal)
# 2191 (Preorder Traversal)
post_order(tree['A'])
|(Inorder Traversal)
8
191순회(pre-order traverse): A - B - D - E → G→F→G
· 트리의 정보를 시각적으로 확인할 수 있습니다.
|(post-order traverse): D - E → B - →G → C → A
# 4 (Postorder Traversal)
[트리 관련 용어]
(in-order traverse): D - B- EAF
[입력 예시]
C
15
[입력 예시 ]
· 이진 탐색이 동작할 수 있도록 고안된 효율적인 탐색이 가능한 자료구조의 일종입니다.
순회(in-order traverse): D → B → E → A → F C G
[Step 1] 루트 노드부터 방문하여 탐색을 진행합니다.
트리의 순회 (Tree Traversal) 구현 예제
3
· 트리 자료구조에 포함된 노드를 특정한 방법으로 한 번씩 방문하는 방법을 의미합니다.
• Ol |(in-order traverse): D → B → E → A → F→ C → G.
print(node.data, end=' ')
# $9 (Postorder Traversal)
replit/repls/WellmadeDeepskyblueBootstrapping
if node.left_node = None:
· 이진 탐색 트리가 이미 구성되어 있다고 가정하고 데이터를 조회하는 과정을 살펴봅시다.
• 1 회(in-order traverse): D → B → E → A F→ C G
→ C replit/repls/WellmadeDeepskyblueBootstrapping
def
°. 부모 노드보다 오른쪽 자식 노드가 큽니다.
Inorder Traversal)
4
v
34
· |(inorder traverse): D - B- EA F-ACG
35
o pre_order(tree[node. left_node ])
def pre_order (node):
data, left_node, right_node = input().split()
른
· 찾고자 하는 원소: 37
def post_order (node):
Replit - WellmadeDeepskyblue. X ndb796 (Dongbin Na) - GitHub x
38
9
# 9 (Postorder Traversal)
(30)
중위 순회(in-order traverse): D → B → E → A → F→ →G
• Oo |(in-order traverse): D → B → E → A → F = C G
Talk
n = int(input())
Q
• 기본적으로 트리의 크기가 N일 때, 전체 간선의 개수는 N-1개입니다.
· 이진 탐색 트리의 특징: 왼쪽 자식 노드 < 뿌모 노드 < 오른쪽 자식 노드
• 이진 탐색 트리의 특징: 왼쪽 자식 노드 < 부모 노드 < 오른쪽 자식 노드
17
in-order traverse): D B EA F- C- G
후위 순회(post-order traverse): 오른쪽 자식을 방문한 뒤에 루트를 방문합니다.
Files
e main.py
pre_order(tree['A'])
if node.right node != None:
• 1912 |(pre-order traverse): A - B D - E → C → F→G
우
• 높이(height): 깊이 중 최댓값
o (in-order traverse): D B EA F- C G
36
def pre_order(node):
40
- 0
• 찾고자 하는 원소: 37
• 차수(degree): 각 노드의 (자식 방향) 간선 개수
으서수의 크Drinritv nuD I이
DBEAFCG
• 중위 순회(in-order traverse): 왼쪽 자식을 방문한 뒤에 루트를 방문합니다.
&
• Ol 회(in-order traverse): D → B → E → A F→ C → G.
쪽
· 트리는 가계도와 같은 계층적인 구조를 표현할 때 사용할 수 있는 자료구조입니다.
후위 순회(post-order traverse): D → E - B → F - G - C - A
· 4순회(in-order traverse): D – B → E→A→F→C→G
(post-order traverse): D EBF- G CA
(Preorder Traversal )
E None None
(pre-order traverse): A - BD E-» C- F - G
(post-order traverse): DEB F> G CA
self data = data
post_order(tree[node. left_node ])
if node.leftnode != None:
• 크기(size): 트리에 포함된 모든 노드의 개수
(pre-order traverse): A B D E C F G
Repl.it - WellmadeDeepskyblue x ndb796 (Dongbin Na) · GitHub x
A
CEG
• 부모 노드보다 왼쪽 자식 노드가 작습니다.
5
print (noae.aata, ena
트리의 순회 (Tree Traversal) |
E2] (Tree)
class Node:
(pre-order traverse): A B D E-» C- F - G
DE BFGCAS
• E11 회(pre-order traverse): A - B - D → E C→F→G
m
30
in_order(tree[node.left_node ])
ABDECFG
• 192|(pre-order traverse): A + B D → E → C → F→G
· (in-order traverse): D - B- EA F-ACG
E트리 (Tree)
. 부모 노드보다 오른쪽 자식 노드가 큽니다.
순회(in-order traverse): D → B → E → A → F→C→G
E29
print(node.data, end='')
중위 순회(in-order traverse): D → B → E → A → F→C → G
# 4 (Inorder Traversal)
37
• [Step 3] 현재 노드와 값을 비교합니다.
o |(in-order traverse): D B B A F-ACG
def __init_(self, data, left_node, right_node):
-
Replit - WellmadeDeepskyblue x ndb796 (Dongbin Na) · GitHub x
43
46
ABDECF G
· 차수(degree): 각 노드의 (자식 방향) 간선 개수
self.left_node = left_node
pre_order(tree[node. right_node ])
| 2) 찾는 원소가 더 크므로 오른쪽 방문
in_order(tree[node.right_node])
24
|(in-order traverse): D - B - E “A → F C G
if node.left_node != None:
· 이진 탐색 트리의 특징: 왼쪽 자식 노드 < 부모 노드 < 오른쪽 자식 노드
D
트리의 순회 Tree Traversal)
# 2 9 |(Inorder Traversal)
위
11
12
14
(pre-order traverse): A- B D E-» C- F - G
• ¢ 1 20|(post-order traverse): D - E → B F - G C - A
• ¢ £|(post-order traverse): D - E - B - F - G - C - A
(post-order traverse): D E B F- G - C- A
27
replit/repls/Wellmade DeepskyblueBootstrapping
42
23
(Inorder Traversal)
Stop
→ C r epl.it/repls/Wellmade DeepskyblueBootstrapping
def in_order (node):
• 대표적인 트리 순회 방법은 다음과 같습니다.
45
B E
ABC
10
DBE AFCG
DEBFGCA:
47
DBE AFC G
Sign up
1
left_node = None
• [Step 2] 현재 노드와 값을 비교합니다.
(pre-order traverse): A- BD E-» C- F - G
이진 탐색 트리가 이미 구성되어 있다고 가정하고 데이터를 조회하는 과정을 살펴봅시다.
이진 탐색 트리 (Binary Search Tree)
DE BFGCA:
• ¢ 1 20|(post-order traverse): D.- E → B F - G C - A
2) 원소를 찾았으므로 탐색을 종료
if node.left_node != None
post_order(tree[node. right_node ])
2
АВС
G
pre_order(tree[node. left_node ])
50
| |(post-order traverse): D - E - B - F - G CA
• 찾고자 하는 원소: 37.
• £순회(in-order traverse): D → B → E → A→ F→C→G
22
CF G
25
in_order(tree[ 'A'])
큐(Priority Queue)
def _init__(self, data, left_node, right_node):
main.py
I
(post-order traverse): D EB F G - CA
F
1) 현재 노드와 찾는 원소 37을 비교
pre_order(tree'A'])
2) 찾는 원소가 더 크므로 오른쪽 방문
26
순회(in-order traverse): D → B → E → A→ F→C→G
def in_order
def post_order(node):
• 전위 순회(pre-order traverse): 루트를 먼저 방문합니다.
L
Python 3.8.2 (default, Feb 26 2020, 02:56:10)
· 이진 탐색 트리의 특징: 왼쪽 자식 노드< 부모 노드 < 오른쪽 자식 노드
· 이진 탐색 트리의 특징: 왼쪽 자식 노드 <부모 노드 < 오른쪽 자식 노드
28
if node.left_node"!= None:
tree[data] = Node (data, left_node, right_node)
Repl.it - WellmadeDeepskyblue x
self.data = data
· 후위 순회(post-order traverse): 오른쪽 자식을 방문한 뒤에 루트를 방문합니다.
|(pre-order traverse): A - BD E- - E -C-G
33
right_node = None
F None None
(post-order traverse): D EBF> G C A
깊이(depth): 루트 노드부터의 거리
• 부모 노드보다 오른쪽 자식 노드가 큽니다.